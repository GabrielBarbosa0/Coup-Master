<!doctype html>
<html lang="pt-BR">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Coup Master - Protótipo Online</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400..900&display=swap" rel="stylesheet">


  <style>
    :root {
      --bg: #171d26;
      --panel: #232a33;
      --accent: #1e90ff;
      --card-radius: 10px;
      --dotted: 3px dotted rgba(255, 255, 255, 0.12);
      --text: #e6eef6;
      --muted: rgba(230, 238, 246, 0.25);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }


    * {
      font-family: "Cinzel", serif !important;

    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: #14171e;
      color: var(--text);
    }


    .container {
      max-width: 1100px;
      margin: 18px auto;
      padding: 12px;
    }

    header {
      border-radius: 18px;
      border: 3px dashed rgba(255, 255, 255, 0.12);
      padding: 26px 18px;
      text-align: center;
      background: #232a33;
      color: #ffffff;
      margin-bottom: 18px;
      font-family: "Orbitron", sans-serif;
    }

    header h1 {
      margin: 0;
      font-size: 34px;
      letter-spacing: 1px;
    }

    header p {
      margin: 6px 0 0;
      color: #444;
    }

    .resetBtn {
      width: 36px;
      height: 36px;
    }

    .infoBtn {
      width: 36px;
      height: 36px;
    }

    .shuffleBtn {
      width: 36px;
      height: 36px;
    }

    .infoBtn img {
      width: 100%;
      height: 100%;
      display: block;
    }


    /* Board */
    .board {
      background: var(--bg);
      border-radius: 14px;
      border: 3px dashed rgba(255, 255, 255, 0.12);
      padding: 18px;
      box-shadow: 0 8px 24px rgba(10, 10, 12, 0.08);
    }

    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .room {
      color: var(--muted);
      font-size: 14px;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .controls button {
      padding: 8px 10px;
      border-radius: 8px;
      border: 0;
      background: var(--panel);
      color: white;
      cursor: pointer;
    }
    
    /* NOVO ESTILO: BOTÃO REMOVER CENTRALIZADO */
    #kickPlayerBtn {
        background: #9d2525;
        font-weight: bold;
    }
    #kickPlayerBtn:hover {
        background: #c34444;
    }


    /* Central area layout (NOVO) */
    .center-area {
      display: flex;
      flex-direction: column;
      gap: 18px;
      /* Espaço entre a linha dos players e a linha da mesa */
    }

    /* (NOVO) Container para os 4 jogadores no topo */
    .player-hands-container {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 18px;
    }

    /* (NOVO) Container para a Área Livre e Deck embaixo */
    .bottom-table-container {
      display: grid;
      grid-template-columns: 3fr 1fr;
      gap: 18px;
      align-items: stretch;
    }

    /* Player areas labels (AJUSTADO) */
    .player-area {
      border-radius: 10px;
      border: 3px dashed #ffffff0f;
      padding: 8px;
      min-height: 140px;
      display: flex;
      /* Esta linha já existe */
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
    }

    /* === [NOVO] Adicione esta regra === */
    /* Esconde todos os jogadores por padrão para evitar o "flash" */
    .player-hands-container>.player-area {
      display: none;
    }

    /* === [FIM DA NOVA REGRA] === */

    /* [NOVO] ESTILO PARA O JOGADOR ATIVO */
    .player-area.active-turn {
      border-color: #00ff73; /* Verde para destacar */
      box-shadow: 0 0 10px #00ff7380;
    }


    .player-title {
      font-weight: 600;
      margin-bottom: 8px;
      color: var(--muted);
    }

    .player-area.local-player .player-title {
      color: var(--accent);
      font-weight: 700;
    }

    /* Deck area (AJUSTADO) */
    .deck-area {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 18px;
      border-radius: 18px;
      border: 3px dashed rgba(255, 255, 255, 0.08);
      background: var(--panel);
      min-height: 200px;
    }

    .deck {
      width: 76px;
      height: 110px;
      border-radius: 10px;
      cursor: pointer;

      /* [NOVO] Aplicando a imagem de verso no Deck */
      background-image: url('./img/back.png');
      background-size: cover;
      background-position: center;

      border: #1e90ff 3px solid;

      /* Esconde o texto "Deck" que estava lá antes */
      text-indent: -9999px;
      overflow: hidden;
    }

    .pile-info {
      display: flex;
      gap: 12px;
      align-items: center;
      text-align: center;
    }

    /* Free area below (AJUSTADO) */
    .free-area {
      border-radius: 12px;
      border: 3px dashed rgba(255, 0, 0, 0.5);
      padding: 18px;
      min-height: 200px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: flex-start;
      justify-content: flex-start;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.02));
      text-align: center;
    }


    /* Cards */
    .card {
      width: 92px;
      height: 128px;
      border-radius: 10px;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      cursor: grab;
      user-select: none;
      /* [NOVO] Estilos para a imagem de fundo */
      background-size: cover;
      /* Ajusta a imagem para cobrir o elemento */
      background-position: center;
      /* Centraliza a imagem */
      background-repeat: no-repeat;
      /* Evita repetição */
      display: block;
      /* Garante que a div se comporta como um bloco para a imagem */
      text-indent: -9999px;
      /* Esconde o texto para leitores de tela */
      overflow: hidden;
      /* Garante que o texto escondido não afete o layout */
    }



    .card:active {
      cursor: grabbing;
    }

    .card.small {
      width: 74px;
      height: 108px
    }


    .card:active {
      cursor: grabbing;
    }


    .card.back {
      background-image: url('./img/back.png');
      color: transparent
    }

    .card .label {
      padding: 6px;
      text-align: center;
      color: #0b0b0b
    }

    /* Hand layout */
    .player-hand {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      /* [CORREÇÃO] MUDADO de 'nowrap' para 'wrap' */
      padding: 6px;
    }


    /* [CORREÇÃO] Aplicando o Grid de 2 colunas no seletor correto */
    .player-stack {
      display: grid;
      grid-template-columns: repeat(2, auto);
      gap: 8px;
      justify-content: center;
      align-items: center;
      padding: 6px;
      width: 100%;
    }

    /* Points controls */
    .points {
      position: absolute;
      right: 8px;
      top: 8px;
      display: flex;
      align-items: center;
      gap: 4px; /* Adicionado para separar os botões */
    }

    .points button {
      padding: 4px 8px;
      border-radius: 6px;
      border: 0;
      background: #f6c204;
      color: #000;
      font-family: Impact, Haettenschweiler, 'Arial Narrow Bold', sans-serif;
      cursor: pointer
    }
    
    /* REMOVIDO ESTILO .REMOVE-PLAYER INDIVIDUAL */


    .points .score {
      min-width: 28px;
      text-align: center;
      color: #fff;
    }

    /* small labels */
    .muted {
      color: var(--muted);
      font-size: 12px
    }

    /* small helpers */
    .slot {
      width: 96px;
      height: 136px;
      border-radius: 10px;
      border: 2px dashed rgba(255, 255, 255, 0.06);
      display: flex;
      align-items: center;
      justify-content: center
    }

    .slot.small {
      width: 76px;
      height: 110px
    }

    /* Responsive adjustments */
    @media (max-width:1024px) {
      .container {
        padding: 8px
      }

      header h1 {
        font-size: 28px
      }

      .player-hands-container {
        grid-template-columns: repeat(2, 1fr);
        /* 2x2 grid para tablets */
      }

      .bottom-table-container {
        grid-template-columns: 1fr;
        /* Stacka área livre e deck */
      }

      .deck {
        width: 76px;
        height: 110px
      }

      .card {
        width: 72px;
        height: 100px
      }

      .slot {
        width: 76px;
        height: 110px
      }

      .player-hand {
        gap: 8px
      }

      .card.small {
        width: 72px;
        height: 107px
      }

      .free-area {
        min-height: 120px
      }
    }

    @media (max-width:520px) {
      .center-area {
        gap: 8px;
      }

      .player-hands-container {
        grid-template-columns: 1fr;
        /* Stacka os 4 players */
        gap: 8px;
      }

      .bottom-table-container {
        grid-template-columns: 1fr;
        /* Stacka área livre e deck */
        gap: 8px;
      }

      .card {
        width: 58px;
        height: 84px
      }

      .slot {
        width: 58px;
        height: 84px
      }

      .player-area {
        padding: 6px;
        min-height: 110px;
      }

      .points {
        right: 4px;
        top: 4px
      }
    }

    /* === ESTILOS DO MODAL E FLIP-CARD === */
    .modal-overlay {
      display: none;
      /* Escondido por padrão */
      position: fixed;
      /* Cobre a tela inteira */
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      /* Fundo escuro */

      /* Para centralizar o conteúdo */
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      position: relative;
      padding: 20px;
      /* O tamanho é definido pelo flip-card */
    }

    .close-btn {
      position: absolute;
      top: -10px;
      right: -10px;
      z-index: 1001;
      color: #fff;
      background: #ff3b3b;
      border: 2px solid white;
      border-radius: 50%;
      width: 35px;
      height: 35px;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      line-height: 30px;
      /* Alinha o 'X' verticalmente */
      text-align: center;
      /* Alinha o 'X' horizontalmente */
    }

    .close-btn:hover {
      background: #ff5555;
    }

    /* --- Estilos do Flip-Card --- */
    .flip-horizontal-left:hover .flip-card-inner {
      transform: rotateY(-180deg);
    }

    .flip-horizontal-left .flip-card-back {
      transform: rotateY(-180deg);
    }

    .flip-card {
      background-color: transparent;
      width: 300px;
      height: 450px;
      perspective: 1000px;
    }

    .flip-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 1s;
      transform-style: preserve-3d;
    }

    .flip-card-front,
    .flip-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
    }

    .flip-card-front img,
    .flip-card-back img {
      width: 100%;
      height: 100%;
      border-radius: 25px;
      object-fit: cover;
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>Coup Master</h1>
    </header>

    <div class="board">
      <div class="top-row">
        <div class="room muted"> </div>
        <div class="controls">
          <button id="resetBtn" class="resetBtn" title="Resetar Mesa"><img src="img/cached.svg" alt=""></button>
          <button id="infoBtn" class="infoBtn" title="Ver Ações"><img src="img/info.svg" alt=""></button>
          
          <button id="kickPlayerBtn" title="Remover Jogador Manualmente" style="background: #9d2525; color: white;">Kickar Jogador</button>
        </div>
      </div>

      <div class="center-area" id="centerArea">

        <div class="player-hands-container">

          <div class="player-area" id="player-1" data-player="1">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 1</div>
            <div class="player-stack hand" data-hand></div>
          </div>

          <div class="player-area" id="player-2" data-player="2">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 2</div>
            <div class="player-stack hand" data-hand></div>
          </div>

          <div class="player-area" id="player-3" data-player="3">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 3</div>
            <div class="player-stack hand" data-hand></div>
          </div>

          <div class="player-area" id="player-4" data-player="4">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 4</div>
            <div class="player-stack hand" data-hand></div>
          </div>

          <div class="player-area" id="player-5" data-player="5">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 5</div>
            <div class="player-stack hand" data-hand></div>
          </div>

          <div class="player-area" id="player-6" data-player="6">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 6</div>
            <div class="player-stack hand" data-hand></div>
          </div>

          <div class="player-area" id="player-7" data-player="7">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 7</div>
            <div class="player-stack hand" data-hand></div>
          </div>

          <div class="player-area" id="player-8" data-player="8">
            <div class="points">
              <button class="minus">-</button>
              <div class="score" data-score>0</div>
              <button class="plus">+</button>
              </div>
            <div class="player-title">Jogador 8</div>
            <div class="player-stack hand" data-hand></div>
          </div>

        </div>
        <div class="bottom-table-container">

          <div class="free-area" id="freeArea" data-area="free">
            <div class="muted" style="width:100%;">Área livre — arraste cartas aqui para torná-las visíveis a todos
            </div>
          </div>

          <div class="deck-area" id="deck-area">
            <div class="pile-info muted">
            </div>
            <div class="deck" id="deck" draggable="true">Deck</div>
            <div class="pile-info muted">
              <div>Cartas no deck: <span id="deck-count"></span><br>Clique para comprar</div>

            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <div id="infoModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
      <button id="closeModalBtn" class="close-btn">&times;</button>

      <div class="flip-card flip-horizontal-left">
        <div class="flip-card-inner">
          <div class="flip-card-front">
            <img src="img/front-actions.jpg" alt="Ações Personagens - Frente">
          </div>
          <div class="flip-card-back">
            <img src="img/back-actions.jpg" alt="Ações Personagens - Verso">
          </div>
        </div>
      </div>
    </div>
  </div>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <script>

    // =======================================================
    // === 1. INICIALIZAÇÃO E CONFIGURAÇÃO DO FIREBASE ===
    // =======================================================

    const firebaseConfig = {
      apiKey: "AIzaSyDQwhYeLEvJW4p9Ml4pKjmr520CeKnZa60",
      authDomain: "coup-master.firebaseapp.com",
      databaseURL: "https://coup-master-default-rtdb.firebaseio.com",
      projectId: "coup-master",
      storageBucket: "coup-master.firebasestorage.app",
      messagingSenderId: "876117110623",
      appId: "1:876117110623:web:b957a148f9f60a51b550ea",
      measurementId: "G-2BQR65QP2Z"
    };

    // Inicializa o Firebase
    if (!firebaseConfig.apiKey) {
      document.body.innerHTML = "<h1>Erro: configure o firebaseConfig no script!</h1>";
      console.error("Firebase config is missing!");
    }

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const gameStateRef = db.ref('gameState');

    // =======================================================
    // === 2. CONSTANTES E VARIÁVEIS GLOBAIS ===
    // =======================================================

    const CARD_TYPES = [
      { type: 'duque', color: '#f6b04d' },
      { type: 'capitao', color: '#ff3b3b' },
      { type: 'assassino', color: '#3aff7b' },
      { type: 'embaixador', color: '#49f0ff' },
      { type: 'condessa', color: '#ffb000' },
      { type: 'inquisidor', color: '#2a8cff' }, // Nome Inquisidor está correto
    ];

    // O estado local é um "espelho" do que está no Firebase
    let localGameState = {};
    let myPlayerId = null;
    let isDrawingCard = false; // Trava para cliques rápidos no deck

    // Referências do DOM
    const deckCountEl = document.getElementById('deck-count');
    const graveCountEl = document.getElementById('grave-count');
    const deckEl = document.getElementById('deck');
    const freeArea = document.getElementById('freeArea');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const kickPlayerBtn = document.getElementById('kickPlayerBtn'); // [NOVO]

    // =======================================================
    // === 3. FUNÇÕES DE CRIAÇÃO E MANIPULAÇÃO DO JOGO (LÓGICA) ===
    // =======================================================

    function createDeck() {
      let newDeck = [];
      let id = 1;
      for (let t = 0; t < CARD_TYPES.length; t++) {
        for (let i = 0; i < 5; i++) {
          newDeck.push({
            id: 'c' + (id++),
            type: CARD_TYPES[t].type,
            color: CARD_TYPES[t].color,
            owner: null,
            visible: false,
            location: 'deck'
          });
        }
      }
      shuffle(newDeck);
      return newDeck;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    // Encontra uma carta dentro do objeto de estado do jogo
    function findCardById(state, id) {
      if (!state || !id) return null;
      let card = state.deck?.find(c => c.id === id);
      if (card) return card;
      card = state.freeCards?.find(c => c.id === id);
      if (card) return card;
      card = state.grave?.find(c => c.id === id);
      if (card) return card;

      for (let p = 1; p <= 8; p++) {
        card = state.players?.[p]?.hand?.find(c => c.id === id);
        if (card) return card;
      }
      return null;
    }

    // Remove uma carta de qualquer lugar em um objeto de estado
    function removeCardFromLocation(state, cardId) {
      if (!state || !cardId) return;
      if (state.deck) state.deck = state.deck.filter(c => c.id !== cardId);
      if (state.freeCards) state.freeCards = state.freeCards.filter(c => c.id !== cardId);
      if (state.grave) state.grave = state.grave.filter(c => c.id !== cardId);

      if (state.players) {
        for (let p = 1; p <= 8; p++) {
          if (state.players[p]?.hand) {
            state.players[p].hand = state.players[p].hand.filter(c => c.id !== cardId);
          }
        }
      }
    }

    // =======================================================
    // === 4. FUNÇÕES DE RENDERIZAÇÃO (ATUALIZAR A TELA) ===
    // =======================================================

    function clearDOM() {
      document.querySelectorAll('[data-hand]').forEach(h => h.innerHTML = '');
      freeArea.querySelectorAll('.card').forEach(n => n.remove());
      document.querySelectorAll('.slot').forEach(n => n.remove());
      document.querySelectorAll('.player-area.local-player')
        .forEach(el => el.classList.remove('local-player'));
      document.querySelectorAll('.player-area.active-turn')
        .forEach(el => el.classList.remove('active-turn'));
    }

    function createCardElement(card) {
      const el = document.createElement('div');
      el.className = 'card';
      el.draggable = true;
      el.dataset.cardId = card.id;

      if (shouldShowBack(card)) {
        el.classList.add('back');
      } else {
        const imageUrl = `./img/${card.type.toLowerCase()}.png`;
        el.style.backgroundImage = `url('${imageUrl}')`;
      }

      el.addEventListener('dragstart', (ev) => {
        ev.dataTransfer.setData('text/plain', card.id);
      });

      el.addEventListener('dblclick', () => {
        returnCardToDeck(card.id);
      });

      return el;
    }

    function shouldShowBack(card) {
      if (card.location === 'deck') return true;
      if (card.location === 'free') return false;
      if (card.location?.startsWith('player-')) {
        return card.owner !== myPlayerId;
      }
      return false;
    }

    // A função de renderização principal
    function renderAll() {
      const state = localGameState;
      if (!state || !state.players) return;

      clearDOM();

      for (let pid = 1; pid <= 8; pid++) {

        const playerEl = document.getElementById(`player-${pid}`);
        if (!playerEl) continue;

        const player = state.players[pid] || { online: false, hand: [], score: 0 };

        // [NOVO] DESTAQUE DE TURNO
        if (state.turn === pid) {
            playerEl.classList.add('active-turn');
        }

        // LÓGICA DE MOSTRAR/OCULTAR
        if (player.online) {
          playerEl.style.display = 'flex';
        } else {
          playerEl.style.display = 'none';
          continue;
        }

        const handContainer = document.querySelector(`#player-${pid} [data-hand]`);

        if (pid === myPlayerId) {
          playerEl.classList.add('local-player');
        }

        // 1. Renderiza os slots que TÊM cartas
        player.hand?.forEach((card) => {
          const slot = document.createElement('div');
          slot.className = 'slot small';

          const el = createCardElement(card);
          el.classList.add('small');

          slot.appendChild(el);
          handContainer.appendChild(slot);
        });

        // 2. Se a mão estiver vazia, mostra UM slot vazio
        if (!player.hand || player.hand.length === 0) {
          const slot = document.createElement('div');
          slot.className = 'slot small';
          handContainer.appendChild(slot);
        }

        // Atualiza pontuação
        const scoreEl = document.querySelector(`#player-${pid} .score`);
        scoreEl.textContent = player.score || 0;
      }

      // Renderiza cartas da área livre
      state.freeCards?.forEach(card => {
        const el = createCardElement(card);
        el.classList.add('small');
        freeArea.appendChild(el);
      });

      // Atualiza contadores
      deckCountEl.textContent = state.deck?.length || 0;
      if (graveCountEl) {
        graveCountEl.textContent = state.grave?.length || 0;
      }
    }

    // =======================================================
    // === 5. AÇÕES DO JOGADOR (ESCREVEM NO FIREBASE) ===
    // =======================================================

    function drawCard() {
      if (!myPlayerId) return;

      if (isDrawingCard) {
        console.log("Aguarde, comprando carta...");
        return;
      }
      isDrawingCard = true;

      gameStateRef.transaction((currentState) => {
        if (!currentState) return currentState;

        if (!currentState.deck || currentState.deck.length === 0) {
          console.log("Deck vazio.");
          return currentState;
        }

        const card = currentState.deck.pop();
        card.owner = myPlayerId;
        card.location = 'player-' + myPlayerId;
        card.visible = false;

        if (!currentState.players[myPlayerId].hand) {
          currentState.players[myPlayerId].hand = [];
        }
        currentState.players[myPlayerId].hand.push(card);

        return currentState;
      },
        (error, committed, snapshot) => {
          if (error) {
            console.error("Falha ao comprar carta:", error);
          }
          // Destrava a função, com sucesso ou falha
          isDrawingCard = false;
        });
    }


    function returnCardToDeck(cardId) {
      gameStateRef.transaction((currentState) => {
        if (!currentState) return currentState;

        const card = findCardById(currentState, cardId);
        if (!card) return currentState;

        removeCardFromLocation(currentState, cardId);

        card.owner = null;
        card.location = 'deck';
        card.visible = false;
        if (!currentState.deck) currentState.deck = [];
        currentState.deck.push(card);

        shuffle(currentState.deck);

        return currentState;
      });
    }

    function moveCard(cardId, targetLocation, targetPlayerId = null) {
      gameStateRef.transaction((currentState) => {
        if (!currentState) return currentState;

        const card = findCardById(currentState, cardId);
        if (!card) return currentState;

        if (targetLocation === 'player') {
          removeCardFromLocation(currentState, cardId);
          card.owner = targetPlayerId;
          card.location = 'player-' + targetPlayerId;
          card.visible = false;
          if (!currentState.players[targetPlayerId].hand) {
            currentState.players[targetPlayerId].hand = [];
          }
          currentState.players[targetPlayerId].hand.push(card);
        }
        else if (targetLocation === 'free') {
          removeCardFromLocation(currentState, cardId);
          card.owner = null;
          card.location = 'free';
          card.visible = true;
          if (!currentState.freeCards) currentState.freeCards = [];
          currentState.freeCards.push(card);
        }
        else if (targetLocation === 'deck') {
          removeCardFromLocation(currentState, cardId);
          card.owner = null;
          card.location = 'deck';
          card.visible = false;
          if (!currentState.deck) currentState.deck = [];
          currentState.deck.push(card);
          shuffle(currentState.deck);
        }

        return currentState;
      });
    }

    // [NOVA FUNÇÃO] KICK PLAYER
    function kickPlayer(pid) {
      if (!confirm(`Tem certeza que deseja remover o Jogador ${pid}?`)) {
        return;
      }
      
      // 1. Remove a persistência local (se for o próprio jogador)
      if (pid === myPlayerId) {
         localStorage.removeItem('myPlayerId');
         myPlayerId = null; // Zera a ID local
         alert('Você foi removido da sala e seu slot está liberado. Recarregue a página para continuar.');
      }

      // 2. Atualiza o Firebase para 'online: false'
      db.ref(`gameState/players/${pid}`).update({
        online: false
      });
    }


    function updateScore(pid, amount) {
      const scoreRef = db.ref(`gameState/players/${pid}/score`);
      scoreRef.once('value', (snapshot) => {
        let newScore = (snapshot.val() || 0) + amount;
        if (newScore < 0) newScore = 0;
        scoreRef.set(newScore);
      });
    }

    function resetTable() {
      console.log("Resetando a mesa...");
      let newDeck = createDeck();

      let currentPlayers = localGameState.players || {};

      let newPlayersState = {
        1: { online: currentPlayers[1]?.online || false, hand: [], score: 2 },
        2: { online: currentPlayers[2]?.online || false, hand: [], score: 2 },
        3: { online: currentPlayers[3]?.online || false, hand: [], score: 2 },
        4: { online: currentPlayers[4]?.online || false, hand: [], score: 2 },
        5: { online: currentPlayers[5]?.online || false, hand: [], score: 2 },
        6: { online: currentPlayers[6]?.online || false, hand: [], score: 2 },
        7: { online: currentPlayers[7]?.online || false, hand: [], score: 2 },
        8: { online: currentPlayers[8]?.online || false, hand: [], score: 2 },
      };

      let initialState = {
        deck: newDeck,
        grave: [],
        freeCards: [],
        turn: 1, // Inicia o turno no jogador 1
        players: newPlayersState
      };

      gameStateRef.set(initialState);
    }

    function shuffleDeck() {
      gameStateRef.transaction((currentState) => {
        if (currentState && currentState.deck) {
          shuffle(currentState.deck);
        }
        return currentState;
      });
    }
    
    // Função separada para lidar com a busca e o claim atômico
    function findNewSlot() {
        gameStateRef.transaction((currentState) => {
            if (!currentState || !currentState.players) {
                // Criação inicial da sala (JOGADOR 1)
                let newDeck = createDeck();
                let initialState = {
                    deck: newDeck,
                    grave: [],
                    freeCards: [],
                    turn: 1, // Inicia o turno no jogador 1
                    players: {
                        1: { hand: [], score: 2, online: true },
                        2: { hand: [], score: 2, online: false }, 3: { hand: [], score: 2, online: false }, 
                        4: { hand: [], score: 2, online: false }, 5: { hand: [], score: 2, online: false },
                        6: { hand: [], score: 2, online: false }, 7: { hand: [], score: 2, online: false },
                        8: { hand: [], score: 2, online: false },
                    }
                };
                myPlayerId = 1;
                localStorage.setItem('myPlayerId', 1);
                return initialState;
            }

            // Busca um slot vazio (online: false)
            for (let i = 1; i <= 8; i++) {
                if (!currentState.players[i] || !currentState.players[i].online) {
                    // Ocupa o slot atomicamente
                    currentState.players[i] = currentState.players[i] || {};
                    currentState.players[i].online = true;
                    currentState.players[i].score = currentState.players[i].score || 2; 
                    currentState.players[i].hand = currentState.players[i].hand || [];
                    myPlayerId = i;
                    localStorage.setItem('myPlayerId', i);
                    return currentState;
                }
            }

            // Sala cheia, não pode entrar
            return; // Aborta a transação
        }, (error, committed, snapshot) => {
            if (committed) {
                console.log(`Entrei com sucesso: Jogador ${myPlayerId}`);
                setupDisconnectHandler(myPlayerId);
            } else if (error) {
                console.error("Erro na transação:", error);
                alert("Erro de conexão ao entrar na sala. Tente novamente.");
            } else {
                // Sala cheia
                alert("Sala cheia! (Máx 8 jogadores)");
                document.body.innerHTML = "<h1>Sala cheia. Tente novamente mais tarde.</h1>";
            }
        });
    }

    // Lógica de "Entrar na Sala"
    function findAndOccupySlot() {
        const myPersistedId = localStorage.getItem('myPlayerId');
        
        // Tenta re-ocupar o slot primeiro (Persistência)
        if (myPersistedId) {
            gameStateRef.transaction((currentState) => {
                if (!currentState || !currentState.players) return;
                
                const pid = parseInt(myPersistedId);

                if (currentState.players[pid] && !currentState.players[pid].online) {
                    currentState.players[pid].online = true;
                    myPlayerId = pid;
                    return currentState;
                }
                
                localStorage.removeItem('myPlayerId');
                return; 
            }, (error, committed, snapshot) => {
                if (committed) {
                    console.log(`Reclamei o slot persistido: Jogador ${myPlayerId}`);
                    setupDisconnectHandler(myPlayerId);
                    return;
                }
                findNewSlot(); 
            });
        } else {
            findNewSlot();
        }
    }

    // Handler para quando o jogador fechar a aba
    function setupDisconnectHandler(pid) {
      const playerRef = db.ref(`gameState/players/${pid}`);
      playerRef.onDisconnect().update({
        online: false
      });
    }

    // =======================================================
    // === 7. O "CORAÇÃO" DO JOGO (O Listener Principal) ===
    // =======================================================

    function initializeGame() {
        const persistedId = localStorage.getItem('myPlayerId');
        if (persistedId) {
            myPlayerId = parseInt(persistedId);
        }
        
        if (!firebaseConfig.apiKey) return;

        gameStateRef.on('value', (snapshot) => {
            const state = snapshot.val();
            if (state) {
                localGameState = state;
                renderAll();
            }
        });

        findAndOccupySlot();
        setupUI();
        setupDropzones();
    }

    // Inicia o jogo!
    initializeGame();

  </script>
</body>

</html>